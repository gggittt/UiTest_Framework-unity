# UiTest_Framework-unity

## into 
В ходе знакомства с фреймворком для автоматизации, у меня возникало много вопросов, ответов на которые в коде я не нашёл. Обычно знакомство с такими объемными штуками происходит на онбординге, где будущего пользователя фреймворка сразу погружают в контекст, дают примеры использования, сообщают в чём фреймворк хорош и в чём бесполезен, возможные баги, неочевидности и т.п. 
У меня такой опции нет, поэтому оставляю фидбэк здесь в тексте. 

В идеале (особенно если его часто изучают новые люди) для фреймворка иметь документацию. Можно как просто в тексте, так и в виде примеров, или описания в `///<summary>` к типам и членам класса. Можно не для всего кода, но хотя бы для неочевидных мест. 
Хорошие примеры документации (прямо на главной странице, в readmi): https://github.com/Cysharp/R3, https://github.com/modesttree/Zenject, https://github.com/bazyleu/UniState,  https://github.com/neuecc/UniRx, https://github.com/bazyleu/UniState


Идея фреймворка интересная. Но я в последнее время в, скажем так, синьорном комьюнити Unity вижу больше подвижек в отделении моделей (POCO) от Unity корутин и MonoBehaviour. 
Плюсы такого подхода: 
1) тесты будут более легковесными, время выполнения тестов уменьшается. 
2) тесты становятся "пользователями кода", чем подталкивают программистов писать более качественный код. 
В предоставленном мне фреймворке же всё жёстко на корутинах. Разница подходов (вкупе с другими неочевидносятми в коде) ещё больше запутывает. 

Стоит также добавить, что большие системы и наследование стоит использовать аккуратно. Пару слов об этом на этом стриме K-Syndicate (см таймкод 1:13:34):
[UNIT TESTING ⚡️ Правильно внедряем unit-тесты в Unity проект ](https://youtu.be/6mkrxvyZp0Y?t=4412)

Не говорю, что фреймворк плохой. Мой посыл в том, что отсутствие документации и примеров использования мешает хорошо вникнуть. Два пустых теста это не очень наглядны.

## Штуки, которые меня замедляли

### 1. методы в interface ICheats. Возвращаемый тип, имя метода и аргументы не сходятся по смыслу. 

  1.1 Методы с Get в названии по смыслу должны что-то возвращать. Здесь же (понял только когда открыл dll) должно быть AddX. Но лучше даже уточнить куда "Add" - в верстан, инвентарь, или добавляется бонус "к дереву" за срубку дерева.
  
  ![image](https://github.com/user-attachments/assets/ff911ca7-da57-4ac5-b48b-2e4daef185f3)
  
  1.2 должно быть "IsXEmpty", т.к. тут ничего не "считается"("Count" в названии не нужен). 
  
  ![image](https://github.com/user-attachments/assets/c1a9ff59-c093-4b8c-9306-1e41222ab23f)
  
  1.2.1 Метод CountIsEmpty, исходя только из названия, скорее бы выглядел как-то так:  
  
  ![image](https://github.com/user-attachments/assets/3e33e295-bae0-4286-ae70-eb8bba4a1168)
  
  *просто для примера. В предоставленном проекте Inventory и Cell другие. 

  Naming в программировании очень важен. Неправильно названный метод ведёт к его неправильному использованию, и далее к багам. По написанному мной методу видно, насколько он мог бы отличаться от того что в фреймворке. Извне, не залезая в реализацию метода, легко понять метод неправильно. Если же закапываться в реализацию каждого метода, то на изучение кода уйдёт несколько рабочих дней. 
  
  1.3 Неясно, имелось ли ввиду IsTreeFelled, или MarkTreeAsFelled, где return это ```bool markesSuccessfully```
  
  ![image](https://github.com/user-attachments/assets/9ac5278a-dae5-4c29-b90f-bbe96867bf61)
  
  1.4 `GetGmGo();` чтобы понять что значит сокращение "Gm", пришлось снова лезть в dll. 


### 2. ButtonsGroup.cs
   
2.1 Лучше не держать такую объёмную логику в конструкторе. И в любом случает лучше разбить на методы или локальные функции по нескольку строк. ```Code should read like well-written prose and be clean, lean, and easy to maintain.```
2.2 в используемых в классе словарях ключом было бы лучше сделать enum. Это избавит от возможных опечаток, и это даст человеку, изучающему фреймворк посмотреть сразу список всех опций. 

![image](https://github.com/user-attachments/assets/07747ecd-0275-49ee-b0f3-1c6bcb36014b)

В идеале, эти словари обернуть в свои классы, чтобы их назначении стало понятнее. 

### 3. Дубляж строковых id.
  Например, в UiTestContext.Inventory { get { return _buttons["inventory"]; } } //строка `"inventory"`
  
  и в UiTest_Framework\UiTest\UiTestDll\UiTest\Context\Consts\Inventory\Inventory.Id //тоже строка `"inventory"`

   ![image](https://github.com/user-attachments/assets/234cae29-29c3-423b-977d-53f26711ef76)

  
  При расширении кода кто-то может забыть, что всё слово в нижнем регистре, и попытаться обратиться через buttons["INVENTORY"] или buttons["Inventory"], в результате чего произойдёт ошибка. Лучше держать строку в одном месте, а во всех других местах всегда обращаться через Inventory.Id, или организовать отдельный класс Constants.
  Эта ситуация описывается в принципе DRY.

### 4. Также, затупы я испытывал и при изучении dll:
4.1 
UiTest\Scripts\Cheats.cs
```CSharp
Camera worldCamera = GameObject.Find("UICanvas").GetComponent<Canvas>().worldCamera;
```
Метод GameObject.Find ненадёжный. Геймдизайнер может случайно переименовать имя GameObject, тогда поиск не найдёт ничего. Лучше искать хотя бы по типу: FindObjectOfType. 
4.2 Это ещё ненадёжнее: сломается также если кто-то передвинеть объекты в иерархии
```CSharp
public List<GameObject> FindTree( )
{
    return ( from tree in GameObject.Find( "trees" ).GetComponentsInChildren<TreeContainer>() select tree.gameObject ).ToList<GameObject>();
}
```

5. Нарушение LSP (нужно разделить интерфейсы) в половине реализующих IUiTestChecker (например, UseButtonIsActiveChecker)
```CSharp
public void Init()
{
    throw new System.NotImplementedException();
}
```

6. Commands.cs. в половине методов чувствуется дубляж кода. Лучше переиспользовать код в приватном методе/методах, если логика частично совпадает.
   
![image](https://github.com/user-attachments/assets/c3d1f9ef-e80d-4939-9849-11ceafb60ea7)

## outro

Всё это замедляет, и вынуждает нырять в кишки фреймворка. 

Я привык писать тесты с Unity Test Framework, в отдельной .asmdef, но в том же проекте где и код игры. Когда сразу виден тестируемый код, то в тестах можно и переиспользовать некоторые DTO и типы с логикой, а также сразу можно проверить написанный тест на:
  1) ложноПоложительность: тест должен стать красным, если логика сломалась в сути.
  2) ложноОтрицательность: тест НЕ должен стать красным, если логика по сути не ломалась, если вносились косметические изменения.
Т.е. после написания теста внести изменения в рабочий код, проверить поведение теста, и откатить изменения в рабочем коде. 
В предоставленном мне фреймворке код тестов отделён от кода проекта, что замедляет изучение. 

Приятнее когда фреймворк именно помогает писать, а не загадывает загадки. Например, даёт удобный синтаксис утверждений по типу
- exampleObject.Value.Should().Be(20);
- Assert.AreEqual( 1, someArr.Length );
В предложенном фреймворке я таких методов для assert не уведел. 


Я всё ещё готов к лайвкодингу. Но если там снова будет задача по этому фреймворку, то у меня все эти вопросы останутся. 
Я уверен, фреймворк может выполнять свои задачи. Но для тестового задания он выглядит грубовато. У не знакомого с этим кодом человека уйдёт на вкат в технологию слишком много времени и будет много вопросов. Вместо тестового будет "борьба с фреймворком".

Будет отлично, если засчитаете моё review фреймворка как выполненное в таком необычном формате тестовое.


